Вопросы
1.Что такое обобщение (generic)? 

Термин обобщение означает параметризированный тип. Особая роль параметризированных
типов состоит в том, что они позволяют создавать классы, структуры, интерфейсы, методы и
делегаты, в которых обрабатываемые данные указываются в виде параметра. Схожие с
обобщениями черты имеют шаблоны С++. Однако между шаблонами С++ и обобщениями .NET
есть большая разница. В С++ при создании экземпляра шаблона с конкретным типом необходим
исходный код шаблонов. В отличие от шаблонов С++, обобщения являются не только конструкцией
языка C#, но также определены для CLR. Это позволяет создавать экземпляры шаблонов с определенным
типом-параметром на языке Visual Basic, даже если обобщенный класс определен на C#

2.Пусть дан фрагмент листинга. В какой строчке содержится ошибка?
 
Ответ: 4. 

3.Как можно наложить определенное ограничение на параметр? 

Допустим, что требуется создать метод, оперирующий содержимым потока, включая объекты
типа FileStream или MemoryStream. На первый взгляд, такая ситуация идеально подходит для применения
обобщений, но при этом нужно каким-то образом гарантировать, что в качестве аргументов типа будут
использованы только типы потоков, но не int или любой другой тип. Кроме того, необходимо уведомить
компилятор о том, что методы, определяемые в классе потока, будут доступны для применения. Так, в обобщенном
коде должно быть каким-то образом известно, что в нем может быть вызван метод Read(). Для выхода из
подобных ситуаций в C# предусмотрены ограниченные типы. Указывая параметр типа, можно наложить определенное
ограничение на этот параметр. Это делается с помощью оператора where при указании параметра типа:
class имя_класса where параметр_типа : ограничения { // ... где ограничения указываются списком через запятую.


4.Как можно наложить несколько ограничений на параметр? 

С параметром типа может быть связано несколько ограничений. В этом случае ограничения указываются списком
через запятую. В этом списке первым должно быть указано ограничение class либо struct, если оно присутствует, или
же ограничение на базовый класс, если оно накладывается. Указывать ограничения class или struct одновременно с
ограничением на базовый класс не разрешается. Далее по списку должно следовать ограничение на интерфейс,
а последним по порядку — ограничение new(). Например, следующее объявление считается вполне допустимым:
class MyObj where T : MyClass, IMyInterface, new() { // ...


5.Перечислите все существующие ограничения на типы данных обобщения?

Ограничение на базовый класс
Требует наличия определенного базового класса в аргументе типа. Это ограничение накладывается указанием
имени требуемого базового класса. Разновидностью этого ограничения является неприкрытое ограничение типа,
при котором на базовый класс указывает параметр типа, а не конкретный тип. Благодаря этому устанавливается
взаимосвязь между двумя параметрами типа.

Ограничение на интерфейс
Требует реализации одного или нескольких интерфейсов аргументом типа. Это ограничение
накладывается указанием имени требуемого интерфейса.

Ограничение на конструктор
Требует предоставить конструктор без параметров в аргументе типа. Это ограничение
накладывается с помощью оператора new().

Ограничение ссылочного типа
Требует указывать аргумент ссылочного типа с помощью оператора class.

Ограничение типа значения
Требует указывать аргумент типа значения с помощью оператора struct.

Среди всех этих ограничений чаще всего применяются ограничения на базовый класс и интерфейс,
хотя все они важны в равной степени.

 6. Какое ограничение на тип задано в следующем фрагменте листинга?
 class A 
{ }
 class В : A 
{ }
 class С { }
 class Test where T : A { }
Ответ: ограничение на базовый класс.

7. Какое ограничение на тип задано в следующем фрагменте листинга? 

interface A 
{ }
 class Test where T : class { }

Ответ: ограничение ссылочного типа. 

 8. Какое ограничение на тип задано в следующем фрагменте листинга? 
interface A
 { } 
class Test where T : struct { }

Ответ: ограничение типа значения. 


 9. Приведите примеры, когда обобщенный класс может действовать как базовый или производный класс.

Обобщенные классы могут входить в иерархию классов аналогично необобщенным классам. Следовательно,
обобщенный класс может действовать как базовый или производный класс. Главное отличие между иерархиями
обобщенных и необобщенных классов заключается в том, что в первом случае аргументы типа, необходимые обобщенному
базовому классу, должны передаваться всеми производными классами вверх по иерархии аналогично передаче аргументов конструктора.

В производном классе следует непременно указывать параметры типа, требующиеся его обобщенному базовому классу,
даже если этот производный класс не обязательно должен быть обобщенным. Разумеется, в производный класс можно
свободно добавлять его собственные параметры типа, если в этом есть потребность.

 10.В каких случаях в обобщениях может использоваться оператор default?

Иногда возникает необходимость присвоить переменным универсальных параметров некоторое начальное значение,
в том числе и null. Но напрямую мы его присвоить не можем:
T id = null;

В этом случае нам надо использовать оператор default(T). Он присваивает ссылочным типам
в качестве значения null, а типам значений - значение 0:
class Account<T>
{
    T id = default(T);
}

 11.Поясните как использовать статические переменные в обобщенных классах. 
При типизации обобщенного класса определенным типом будет создаваться свой набор статических членов.
Например, в классе Account определено следующее статическое поле:

class Account<T>
{
    public static T session;
     
    public T Id { get; set; }
    public int Sum { get; set; }
}

Теперь типизируем класс двумя типами int и string:
Account<int> account1 = new Account<int> { Sum = 5000 };
Account<int>.session = 5436;
 
Account<string> account2 = new Account<string> { Sum = 4000 };
Account<string>.session = "45245";
 
Console.WriteLine(Account<int>.session);      // 5436
Console.WriteLine(Account<string>.session);   // 45245

В итоге для Account<string> и для Account<int> будет создана своя переменная session.

12.Приведите пример обобщенного интерфейса.

Помимо обобщенных классов и методов, в C# допускаются обобщенные интерфейсы. Такие интерфейсы
указываются аналогично обобщенным классам. Применяя обобщения, можно определять интерфейсы,
объявляющие методы с обобщенными параметрами.

// Объявляем обобщенный интерфейс
    public interface ISort<T> 
        where T : struct
    {
        void ReWrite();
    }

 13.В чем отличие обобщенных классов от обобщенных структур? 

Подобно классам, структуры также могут быть обобщенными.
Они очень похожи на обобщенные классы, за исключением возможности наследования.

14.Какие классы для работы с файлами вы знаете? Приведите пример

Классы File и FileInfo.
Класс FileStream.
Классы StreamReader и StreamWriter.
Работа с бинарными файлами- классы BinaryWriter и BinaryReader
Создание и чтение сжатых файлов - классы GZipStream и DeflateStream.