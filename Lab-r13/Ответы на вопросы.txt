Вопросы 
1. Какие классы содержаться с System.IO? 
BinaryReader, BinaryWriter
Эти классы позволяют сохранять и извлекать элементарные типы данных (целочисленные, булевские, строковые и т.п.) в двоичном виде

BufferedStream
Этот класс предоставляет временное хранилище для потока байтов, которые могут затем быть перенесены в постоянные хранилища

Directory, DirectoryInfo
Эти классы используются для манипуляций структурой каталогов машины. Тип Directory представляет функциональность, используя статические члены. Тип DirectoryInfo обеспечивает аналогичную функциональность через действительную объектную ссылку

DriveInfo
Этот класс предоставляет детальную информацию относительно дисковых устройств, используемых данной машиной

File, FileInfo
Эти классы служат для манипуляций множеством файлов данной машины. Тип File представляет функциональность через статические члены. Тип FileInfo обеспечивает аналогичную функциональность через действительную объектную ссылку

FileStream
Этот класс обеспечивает произвольный доступ к файлу (т.е. возможности поиска) с данными, представленными в виде потока байт

FileSystemWatcher
Этот класс позволяет отслеживать модификации внешних файлов в определенном каталоге

MemoryStream
Этот класс обеспечивает произвольный доступ к данным, хранящимся в памяти, а не в физическом файле

Path
Этот класс выполняет операции над типами System.String, содержащими информацию о пути к файлу или каталогу в независимой от платформы манере

StreamWriter, StreamReader
Эти классы используются для хранения (и извлечения) текстовой информации из файла. Эти классы не поддерживают произвольного доступа к файлу

StringWriter, StringReader
Подобно классам StreamWriter/StreamReader, эти классы также работают с текстовой информацией. Однако лежащим в основе хранилищем является строковый буфер, а не физический файл

В дополнение к этим конкретным типам классов в System.IO определено несколько перечислений, а также набор абстрактных классов (т.е. Stream, TextReader и TextWriter), которые определяют разделяемый полиморфный интерфейс для всех наследников.

2. Для чего используются классы Directory и DirectoryInfo? В чем отличие? 
Для работы с каталогами в пространстве имен System.IO предназначены сразу два класса: Directory и DirectoryInfo.
Directory – выполняет операции при помощи статических методов.
DirectoryInfo – выполняет операции при помощи экземплярных методов.

3. Для чего используются классы File и FileInfo? Какие методы они содержат. 
Подобно паре Directory/DirectoryInfo для работы с файлами предназначена пара классов File и FileInfo. С их помощью мы можем создавать, удалять, перемещать файлы, получать их свойства и многое другое.

Некоторые полезные методы и свойства класса FileInfo:

CopyTo(path): копирует файл в новое место по указанному пути path

Create(): создает файл

Delete(): удаляет файл

MoveTo(destFileName): перемещает файл в новое место

Свойство Directory: получает родительский каталог в виде объекта DirectoryInfo

Свойство DirectoryName: получает полный путь к родительскому каталогу

Свойство Exists: указывает, существует ли файл

Свойство Length: получает размер файла

Свойство Extension: получает расширение файла

Свойство Name: получает имя файла

Свойство FullName: получает полное имя файла

Класс File реализует похожую функциональность с помощью статических методов:

Copy(): копирует файл в новое место

Create(): создает файл

Delete(): удаляет файл

Move: перемещает файл в новое место

Exists(file): определяет, существует ли файл

4. Для чего используются классы StreamReader и StreamWriter?
Класс FileStream не очень удобно применять для работы с текстовыми файлами. К тому же для этого в пространстве System.IO определены специальные классы: StreamReader и StreamWriter.
Класс StreamReader позволяет нам легко считывать весь текст или отдельные строки из текстового файла. 
Для записи в текстовый файл используется класс StreamWriter. 

5. Для чего используются классы BinaryWriter и BinaryReader? 
Для работы с бинарными файлами предназначена пара классов BinaryWriter и BinaryReader. Эти классы позволяют читать и записывать данные в двоичном формате.

6. Как можно сжимать и восстанавливать файлы? 
Кроме классов чтения-записи .NET предоставляет классы, которые позволяют сжимать файлы, а также затем восстанавливать их в исходное состояние.
Это классы DeflateStream и GZipStream, которые находятся в пространстве имен System.IO.Compression и представляют реализацию одного из алгоритмов сжатия Deflate или GZip.

7. Расскажите алгоритм сжатия GZip.
Этот класс представляет формат данных gzip, который использует стандартный алгоритм для файлов без потерь сжатия и распаковки. Формат включает значение циклической проверки для обнаружения повреждения данных. Формат данных gzip использует тот же алгоритм, DeflateStream класса, но может быть расширен для использования других форматов сжатия. Формат можно легко реализовать в виде, не охваченных патентов.

8. Что такое тестовый и бинарный файл. Как можно выполнить чтение и запись в эти файлы. 
Текстовый файл — компьютерный файл, содержащий текстовые данные. Текстовым файлам противопоставляются двоичные (бинарные) файлы, в которых содержатся данные, не рассчитанные на интерпретацию в качестве текстовых (например, файлы, хранящие текст в закодированном или сжатом виде, или хранящие не текст, а звук, изображение или иные данные).
Чтение и запись можно выполнить с помощью классов StreamReader, StreamWriter  или класса FileStream.
Двоичный (бинарный) файл —  последовательность произвольных байтов.
С чтением бинарных данных все просто: соответствующий метод считывает данные определенного типа и перемещает указатель на размер этого типа в байтах, например, значение типа int занимает 4 байта, поэтому BinaryReader считает 4 байта и переместит указать на эти 4 байта.
Запись бинарных файлов – класс BinaryWriter.

9. Что такое произвольный доступ к файлу? Приведите пример. 
Нередко бинарные файлы представляют определенную стрктуру. И, зная эту структуру, мы можем взять из файла нужную порцию информации или наоброт записать в определенном месте файла определенный набор байтов. Например, в wav-файлах непосредственно звуковые данные начинаются с 44 байта, а до 44 байта идут различные метаданные - количество каналов аудио, частота дискретизации и т.д.
С помощью метода Seek() мы можем управлять положением курсора потока, начиная с которого производится считывание или запись в файл. Этот метод принимает два параметра: offset (смещение) и позиция в файле. Позиция в файле описывается тремя значениями:
•	SeekOrigin.Begin: начало файла
•	SeekOrigin.End: конец файла
•	SeekOrigin.Current: текущая позиция в файле
Курсор потока, с которого начинается чтение или запись, смещается вперед на значение offset относительно позиции, указанной в качестве второго параметра. Смещение может отрицательным, тогда курсор сдвигается назад, если положительное - то вперед.
Рассмотрим на примере:
using System.IO;
using System.Text;
 
class Program
{
    static void Main(string[] args)
    {
        string text = "hello world";
             
        // запись в файл
        using (FileStream fstream = new FileStream(@"D:\note.dat", FileMode.OpenOrCreate))
        {
            // преобразуем строку в байты
            byte[] input = Encoding.Default.GetBytes(text);
            // запись массива байтов в файл
            fstream.Write(input, 0, input.Length);
            Console.WriteLine("Текст записан в файл");
 
            // перемещаем указатель в конец файла, до конца файла- пять байт
            fstream.Seek(-5, SeekOrigin.End); // минус 5 символов с конца потока
 
            // считываем четыре символов с текущей позиции
            byte[] output = new byte[4];
            fstream.Read(output, 0, output.Length);
            // декодируем байты в строку
            string textFromFile = Encoding.Default.GetString(output);
            Console.WriteLine("Текст из файла: {0}", textFromFile); // worl
 
            // заменим в файле слово world на слово house
            string replaceText = "house";
            fstream.Seek(-5, SeekOrigin.End); // минус 5 символов с конца потока
            input = Encoding.Default.GetBytes(replaceText);
            fstream.Write(input, 0, input.Length);
 
            // считываем весь файл
            // возвращаем указатель в начало файла
            fstream.Seek(0, SeekOrigin.Begin);
            output = new byte[fstream.Length];
            fstream.Read(output, 0, output.Length);
            // декодируем байты в строку
            textFromFile = Encoding.Default.GetString(output);
            Console.WriteLine("Текст из файла: {0}", textFromFile); // hello house
        }
        Console.Read();
    }
}

10. Как применяется конструкция using (не директива) при работе с файловыми потоками? Для чего ее используют.  
Не надо путать данный оператор с директивой using, которая подключает пространства имен в начале файла кода. Оператор using позволяет создавать объект в блоке кода, по завершению которого вызывается метод Dispose у этого объекта, и, таким образом, объект уничтожается.